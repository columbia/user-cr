#!/usr/bin/python

# Auto-generate code to convert checkpoint constants to text labels 

import sys
import time
import string
import re

# If no arguments were given, print a helpful message
if len(sys.argv) != 1:
    print 'Usage: ckptinfo.py'
    sys.exit(0)

regx_hdr = re.compile(r"^(\s*CKPT_)(HDR_[A-Z_]*)")
regx_obj = re.compile(r"^(\s*CKPT_)(OBJ_[A-Z_]*)")
regx_file = re.compile(r"^(\s*CKPT_)(FILE_[A-Z_]*)")
regx_vma = re.compile(r"^(\s*CKPT_)(VMA_[A-Z_]*)")

list_hdr = []
list_obj = []
list_file = []
list_vma = []

lineno = 1

def match_something(line, regx, list, type):
    match = regx.search(line)
    if match:
        if match.lastindex != 2:
            print "Multiple %s... matches on line %d" % (type, lineno)
            sys.exit(1)
        list.append(match.group(2))
        return 1
    else:
        return 0

def print_something(list, type):
    print """
char *%s_to_str(int type)
{
	switch (type) {
""" % type
    for key in list:
        print "	case CKPT_%s: return \"%s\";" % (key, key)

    print """
	}
	return "---UNKNOWN---";
}
"""
    return

    
# Iterate over all the lines in the file and aggregate the #define's
# in each category.

while (1):
    lineno = lineno + 1
    line = sys.stdin.readline()
    if line == "": break

    if match_something(line, regx_hdr, list_hdr, "CKPT_HDR_..."):
        pass
    elif match_something(line, regx_obj, list_obj, "CKPT_OBJ_..."):
        pass
    elif match_something(line, regx_file, list_file, "CKPT_FILE_..."):
        pass
    elif match_something(line, regx_vma, list_vma, "CKPT_VMA_..."):
        pass

# Now output the appropriate C code for switch statements that
# convert the constants to strings

print """
/*
 * DO NOT EDIT
 * This file is auto-generated by ckptinfo.py
 */

#include <linux/checkpoint_hdr.h>
"""

print_something(list_hdr, "hdr")
print_something(list_obj, "obj")
print_something(list_file, "file")
print_something(list_vma, "vma")

# Done
